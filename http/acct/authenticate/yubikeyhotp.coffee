# copyright 2013 wiz technologies inc.

require '../../..'
require '../../../crypto/otp'
require './base'

wiz.package 'wiz.framework.http.acct.authenticate.yubikeyhotp'

# Example YubiKey HOTP authentication request:
#
# POST /account/authenticate/yubikeyhotp
#
#	{
#		"leetcode" : "PPPPXXXXXXXXYYYYYYYY" // 20 digit code generated by yubikey token:
#											// P = 4 digit leetcode prefix
#											// X = 8 digit yubikey serial number
#											// Y = 8 digit hotp code
#	}
#

class wiz.framework.http.acct.authenticate.yubikeyhotp extends wiz.framework.http.acct.authenticate.base

	otpValidate: (req, res, acctOTP, userOTP) => #{{{
		secret = new Buffer(acctOTP.secret16, 'hex')
		counter = acctOTP.counter10

		validation = wiz.framework.crypto.otp.validateHOTP(secret, counter, userOTP)

		return true if validation.result is true
		return false
	#}}}

	handler: (req, res) => #{{{
		return @fail(req, res, 'missing parameters') if not req.body?.leetcode?
		return @fail(req, res, 'invalid leetcode') if not wiz.framework.util.strval.leetcode_valid(req.body.leetcode)

		try # parse key id and hotp out of leetcode string
			r = /^1337(\d{8})(\d{8})$/
			leetcode = r.exec(req.body.leetcode)
			keyID = leetcode[1]
			userOTP = leetcode[2]
		catch e
			return @error req, res, "leetcode error: #{e}"

		return @parent.parent.db.otpkeys.findAcctByYubiID req, res, keyID, (req, res, acctID, acctOTP) =>
			return @fail(req, res, 'no such acct') if not acctID or not acctOTP
			return @fail(req, res, 'otp incorrect') if not @otpValidate(req, res, acctOTP, userOTP)

			@parent.parent.db.accounts.findOneByID req, res, acctID, (req, res, acct) =>
				return @fail(req, res, 'no such acct') if not acct
				return @parent.parent.db.otpkeys.otpIncrementCounter req, res, acct, keyID, 1, (result) =>
					return @onAuthenticateSuccess(req, res, acct)
	#}}}

	fail: (req, res, err) => #{{{
		res.send 400, 'yubikey authentication failure', err
	#}}}
	error: (req, res, err) => #{{{
		res.send 500, 'yubikey authentication error', err
	#}}}

# vim: foldmethod=marker wrap
